---
alwaysApply: true
---

# Clerk Authentication & User Data Security

This project uses **Clerk** for authentication. **CRITICAL**: All data access must be user-scoped to prevent unauthorized access to other users' data.

## Core Security Principle

**üö® NEVER allow users to access data that doesn't belong to them. Every database query MUST include user authentication and authorization checks.**

## Authentication Setup

### Middleware Configuration
The [middleware.ts](mdc:src/middleware.ts) file handles authentication routing. The current configuration protects all routes except static assets and Next.js internals.

### Database Schema
The [schema.ts](mdc:src/db/schema.ts) includes `userId` fields that store Clerk user IDs. All user-owned resources MUST reference this field.

## Mandatory Security Patterns

### 1. Always Get Current User
```typescript
// ‚úÖ CORRECT - Always get authenticated user first
import { auth } from "@clerk/nextjs/server";

export async function GET() {
  const { userId } = auth();
  
  if (!userId) {
    return new Response("Unauthorized", { status: 401 });
  }
  
  // Now use userId in database queries
}
```

### 2. User-Scoped Database Queries
```typescript
// ‚úÖ CORRECT - All queries MUST filter by userId
import { eq, and } from "drizzle-orm";
import { db } from "@/db";
import { decksTable, cardsTable } from "@/db/schema";

// Get user's decks ONLY
const userDecks = await db
  .select()
  .from(decksTable)
  .where(eq(decksTable.userId, userId));

// Get user's deck with verification
const userDeck = await db.query.decksTable.findFirst({
  where: and(
    eq(decksTable.id, deckId),
    eq(decksTable.userId, userId) // MANDATORY user check
  ),
  with: { cards: true }
});

// ‚ùå WRONG - Never query without user filtering
const allDecks = await db.select().from(decksTable); // FORBIDDEN
```

### 3. Create Operations
```typescript
// ‚úÖ CORRECT - Always include userId when creating
const [newDeck] = await db
  .insert(decksTable)
  .values({
    title: "New Deck",
    description: "Description",
    userId: userId, // MANDATORY - must include authenticated user's ID
  })
  .returning();

// ‚ùå WRONG - Never create without userId
const badDeck = await db.insert(decksTable).values({
  title: "Deck"
  // Missing userId - FORBIDDEN
});
```

### 4. Update Operations
```typescript
// ‚úÖ CORRECT - Verify ownership before updating
const updatedDeck = await db
  .update(decksTable)
  .set({
    title: "Updated Title",
    updatedAt: new Date(),
  })
  .where(and(
    eq(decksTable.id, deckId),
    eq(decksTable.userId, userId) // MANDATORY ownership check
  ))
  .returning();

// Verify the update affected a row (confirms ownership)
if (updatedDeck.length === 0) {
  return new Response("Deck not found or unauthorized", { status: 404 });
}
```

### 5. Delete Operations
```typescript
// ‚úÖ CORRECT - Verify ownership before deleting
const deletedDeck = await db
  .delete(decksTable)
  .where(and(
    eq(decksTable.id, deckId),
    eq(decksTable.userId, userId) // MANDATORY ownership check
  ))
  .returning();

// Verify the deletion affected a row
if (deletedDeck.length === 0) {
  return new Response("Deck not found or unauthorized", { status: 404 });
}
```

### 6. Related Resource Access (Cards)
```typescript
// ‚úÖ CORRECT - Verify deck ownership when accessing cards
const userCard = await db.query.cardsTable.findFirst({
  where: eq(cardsTable.id, cardId),
  with: {
    deck: {
      where: eq(decksTable.userId, userId) // Verify deck belongs to user
    }
  }
});

if (!userCard?.deck) {
  return new Response("Card not found or unauthorized", { status: 404 });
}
```

## API Route Security Template

### Standard API Route Pattern
```typescript
import { auth } from "@clerk/nextjs/server";
import { db } from "@/db";
import { decksTable } from "@/db/schema";
import { eq, and } from "drizzle-orm";

export async function GET(request: Request) {
  try {
    // 1. ALWAYS authenticate first
    const { userId } = auth();
    if (!userId) {
      return new Response("Unauthorized", { status: 401 });
    }

    // 2. Extract parameters (if any)
    const url = new URL(request.url);
    const deckId = url.searchParams.get("deckId");

    // 3. Query with user filtering
    const userDecks = await db
      .select()
      .from(decksTable)
      .where(
        deckId 
          ? and(eq(decksTable.id, parseInt(deckId)), eq(decksTable.userId, userId))
          : eq(decksTable.userId, userId)
      );

    return Response.json(userDecks);
  } catch (error) {
    console.error("API Error:", error);
    return new Response("Internal Server Error", { status: 500 });
  }
}
```

## Client-Side Authentication

### Use Clerk Hooks
```typescript
// ‚úÖ CORRECT - Use Clerk hooks in components
import { useUser } from "@clerk/nextjs";

export function DashboardComponent() {
  const { user, isLoaded } = useUser();

  if (!isLoaded) return <div>Loading...</div>;
  if (!user) return <div>Please sign in</div>;

  return <div>Welcome, {user.firstName}!</div>;
}
```

### Protect Routes with Clerk Components
```typescript
// ‚úÖ CORRECT - Wrap protected content
import { SignedIn, SignedOut, RedirectToSignIn } from "@clerk/nextjs";

export default function ProtectedPage() {
  return (
    <>
      <SignedIn>
        <ProtectedContent />
      </SignedIn>
      <SignedOut>
        <RedirectToSignIn />
      </SignedOut>
    </>
  );
}
```

## Forbidden Practices

‚ùå **NEVER** query data without user filtering
‚ùå **NEVER** trust client-provided user IDs - always use `auth()` from Clerk
‚ùå **NEVER** skip ownership verification on updates/deletes
‚ùå **NEVER** expose sensitive data in API responses
‚ùå **NEVER** use hardcoded user IDs for testing in production code
‚ùå **NEVER** bypass authentication checks "temporarily"

## Required Verification Steps

### Before ANY database operation:
1. ‚úÖ Authenticate the user with `auth()`
2. ‚úÖ Verify the user has permission to access the resource
3. ‚úÖ Include `userId` filtering in ALL queries
4. ‚úÖ Verify query results to confirm ownership
5. ‚úÖ Handle unauthorized access with appropriate error responses

### For related resources (cards ‚Üí decks):
1. ‚úÖ Always verify parent resource ownership
2. ‚úÖ Use joins or nested queries to enforce user boundaries
3. ‚úÖ Never assume child resources belong to the user

## Environment Variables

Ensure these Clerk environment variables are configured:
- `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY`
- `CLERK_SECRET_KEY`
- `NEXT_PUBLIC_CLERK_SIGN_IN_URL`
- `NEXT_PUBLIC_CLERK_SIGN_UP_URL`

## Testing Security

When testing, always verify:
1. Authenticated users can only access their own data
2. Unauthenticated requests are rejected
3. Users cannot access other users' resources by changing IDs
4. All CRUD operations respect ownership boundaries

**Remember: Security is not optional. Every single database query must enforce user boundaries.**