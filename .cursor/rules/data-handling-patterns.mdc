---
alwaysApply: true
---
# Data Handling Architecture Patterns

This project follows strict patterns for data handling to ensure security, type safety, and performance.

## Database Query Organization

**MANDATORY**: All database operations MUST be centralized in helper functions within the `db/queries` directory. Never perform database operations directly in server components or server actions.

### Directory Structure
```
src/
  db/
    queries/
      deck-queries.ts    # All deck-related database operations
      card-queries.ts    # All card-related database operations
      user-queries.ts    # All user-related database operations
```

## Query Helper Functions for Data Retrieval

**MANDATORY**: All data retrieval operations MUST be performed through helper functions in `db/queries`, which are then called by server components.

### ✅ CORRECT - Query Helper Function Pattern
```typescript
// db/queries/deck-queries.ts
import { db } from "@/db";
import { decksTable, cardsTable } from "@/db/schema";
import { eq, desc, and } from "drizzle-orm";

export async function getUserDecks(userId: string) {
  return await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))
    .orderBy(desc(decksTable.createdAt));
}

export async function getDeckWithCards(deckId: number, userId: string) {
  return await db.query.decksTable.findFirst({
    where: and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId) // MANDATORY user check
    ),
    with: {
      cards: true,
    },
  });
}

export async function getUserDeckById(deckId: number, userId: string) {
  return await db.query.decksTable.findFirst({
    where: and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ),
  });
}
```

### ✅ CORRECT - Server Component Using Query Helper
```typescript
// app/decks/page.tsx (Server Component)
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { getUserDecks } from "@/db/queries/deck-queries";

export default async function DecksPage() {
  const { userId } = auth();
  
  if (!userId) {
    redirect("/sign-in");
  }

  // Use query helper function instead of direct database access
  const decks = await getUserDecks(userId);

  return <DecksGrid decks={decks} />;
}
```

### ❌ WRONG - Direct Database Operations in Server Components
```typescript
// DON'T DO THIS - No direct database operations in server components
import { db } from "@/db";
import { decksTable } from "@/db/schema";

export default async function DecksPage() {
  // FORBIDDEN - Direct database operation
  const decks = await db.select().from(decksTable); // NOT ALLOWED
}
```

## Mutation Helper Functions for Data Modifications

**MANDATORY**: All database mutations (INSERT, UPDATE, DELETE) MUST be performed through helper functions in `db/queries`, which are then called by server actions.

### ✅ CORRECT - Mutation Helper Function Pattern
```typescript
// db/queries/deck-queries.ts
import { db } from "@/db";
import { decksTable } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import { z } from "zod";

// Zod schemas for validation
export const CreateDeckSchema = z.object({
  title: z.string().min(1, "Title is required").max(100),
  description: z.string().max(500).optional(),
});

export const UpdateDeckSchema = z.object({
  id: z.number().positive(),
  title: z.string().min(1, "Title is required").max(100),
  description: z.string().max(500).optional(),
});

export const DeleteDeckSchema = z.object({
  id: z.number().positive(),
});

// Types derived from Zod schemas
export type CreateDeckData = z.infer<typeof CreateDeckSchema>;
export type UpdateDeckData = z.infer<typeof UpdateDeckSchema>;
export type DeleteDeckData = z.infer<typeof DeleteDeckSchema>;

// Mutation helper functions
export async function createDeck(data: CreateDeckData, userId: string) {
  const validatedData = CreateDeckSchema.parse(data);
  
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      ...validatedData,
      userId,
    })
    .returning();

  return newDeck;
}

export async function updateDeck(data: UpdateDeckData, userId: string) {
  const validatedData = UpdateDeckSchema.parse(data);
  
  const [updatedDeck] = await db
    .update(decksTable)
    .set({
      title: validatedData.title,
      description: validatedData.description,
      updatedAt: new Date(),
    })
    .where(and(
      eq(decksTable.id, validatedData.id),
      eq(decksTable.userId, userId) // MANDATORY ownership check
    ))
    .returning();

  if (!updatedDeck) {
    throw new Error("Deck not found or unauthorized");
  }

  return updatedDeck;
}

export async function deleteDeck(data: DeleteDeckData, userId: string) {
  const validatedData = DeleteDeckSchema.parse(data);
  
  const [deletedDeck] = await db
    .delete(decksTable)
    .where(and(
      eq(decksTable.id, validatedData.id),
      eq(decksTable.userId, userId) // MANDATORY ownership check
    ))
    .returning();

  if (!deletedDeck) {
    throw new Error("Deck not found or unauthorized");
  }

  return deletedDeck;
}
```

### ✅ CORRECT - Server Action Using Mutation Helper
```typescript
// app/actions/deck-actions.ts
"use server";

import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import { 
  createDeck, 
  updateDeck, 
  deleteDeck,
  type CreateDeckData,
  type UpdateDeckData,
  type DeleteDeckData
} from "@/db/queries/deck-queries";

export async function createDeckAction(data: CreateDeckData) {
  const { userId } = auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }

  // Use mutation helper function instead of direct database access
  const newDeck = await createDeck(data, userId);

  revalidatePath("/decks");
  return newDeck;
}

export async function updateDeckAction(data: UpdateDeckData) {
  const { userId } = auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }

  // Use mutation helper function
  const updatedDeck = await updateDeck(data, userId);

  revalidatePath("/decks");
  return updatedDeck;
}

export async function deleteDeckAction(data: DeleteDeckData) {
  const { userId } = auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }

  // Use mutation helper function
  await deleteDeck(data, userId);

  revalidatePath("/decks");
}
```

### ❌ WRONG - Direct Database Operations in Server Actions
```typescript
// DON'T DO THIS - No direct database operations in server actions
"use server";

import { db } from "@/db";
import { decksTable } from "@/db/schema";

export async function createDeckAction(data: any) {
  // FORBIDDEN - Direct database operation in server action
  const [newDeck] = await db.insert(decksTable).values(data); // NOT ALLOWED
}
```

## Query Helper Function Requirements

### Security & Authentication
```typescript
// ✅ CORRECT - Always include userId parameter for user-scoped operations
export async function getUserCards(deckId: number, userId: string) {
  // Verify deck ownership before returning cards
  const deck = await getUserDeckById(deckId, userId);
  if (!deck) {
    throw new Error("Deck not found or unauthorized");
  }

  return await db
    .select()
    .from(cardsTable)
    .where(eq(cardsTable.deckId, deckId));
}

// ❌ WRONG - Never omit userId parameter
export async function getAllCards(deckId: number) { // FORBIDDEN
  // Missing user authorization - NOT ALLOWED
}
```

### Validation & Types
```typescript
// ✅ CORRECT - Export Zod schemas and types from query files
export const CreateCardSchema = z.object({
  deckId: z.number().positive(),
  front: z.string().min(1, "Front text is required"),
  back: z.string().min(1, "Back text is required"),
});

export type CreateCardData = z.infer<typeof CreateCardSchema>;

// ✅ CORRECT - Validate data in helper functions
export async function createCard(data: CreateCardData, userId: string) {
  const validatedData = CreateCardSchema.parse(data);
  
  // Verify deck ownership before creating card
  const deck = await getUserDeckById(validatedData.deckId, userId);
  if (!deck) {
    throw new Error("Deck not found or unauthorized");
  }

  const [newCard] = await db
    .insert(cardsTable)
    .values(validatedData)
    .returning();

  return newCard;
}
```

## Error Handling in Query Helpers

```typescript
// ✅ CORRECT - Comprehensive error handling
export async function getDeckWithCards(deckId: number, userId: string) {
  try {
    const deck = await db.query.decksTable.findFirst({
      where: and(
        eq(decksTable.id, deckId),
        eq(decksTable.userId, userId)
      ),
      with: {
        cards: true,
      },
    });

    if (!deck) {
      throw new Error("Deck not found or unauthorized");
    }

    return deck;
  } catch (error) {
    console.error("Failed to fetch deck with cards:", error);
    throw error; // Re-throw to be handled by calling code
  }
}
```

## File Organization Guidelines

### Query File Structure
```typescript
// db/queries/deck-queries.ts
// 1. Imports
import { db } from "@/db";
import { decksTable } from "@/db/schema";
import { z } from "zod";

// 2. Zod Schemas
export const CreateDeckSchema = z.object({...});

// 3. TypeScript Types
export type CreateDeckData = z.infer<typeof CreateDeckSchema>;

// 4. Query Functions (SELECT operations)
export async function getUserDecks(userId: string) {...}

// 5. Mutation Functions (INSERT, UPDATE, DELETE operations)
export async function createDeck(data: CreateDeckData, userId: string) {...}
```

### Naming Conventions
- Query files: `[entity]-queries.ts` (e.g., `deck-queries.ts`, `card-queries.ts`)
- Query functions: `get[Entity][Descriptor]` (e.g., `getUserDecks`, `getDeckWithCards`)
- Mutation functions: `[action][Entity]` (e.g., `createDeck`, `updateCard`, `deleteDeck`)
- Schemas: `[Action][Entity]Schema` (e.g., `CreateDeckSchema`, `UpdateCardSchema`)
- Types: `[Action][Entity]Data` (e.g., `CreateDeckData`, `UpdateCardData`)

## Forbidden Patterns

❌ **NEVER** perform database operations directly in server components
❌ **NEVER** perform database operations directly in server actions
❌ **NEVER** skip user authorization in query helper functions
❌ **NEVER** omit Zod validation in mutation helper functions
❌ **NEVER** use `any` or untyped parameters in helper functions
❌ **NEVER** bypass authentication checks in query helpers
❌ **NEVER** fetch data in client components with useEffect
❌ **NEVER** use API routes for database mutations

## Required File Structure

Every query file should follow this pattern:
```typescript
// db/queries/[entity]-queries.ts
import { db } from "@/db";
import { [entity]Table } from "@/db/schema";
import { eq, and, desc } from "drizzle-orm";
import { z } from "zod";

// Schemas
export const Create[Entity]Schema = z.object({...});

// Types  
export type Create[Entity]Data = z.infer<typeof Create[Entity]Schema>;

// Query functions
export async function getUser[Entity]s(userId: string) {...}

// Mutation functions
export async function create[Entity](data: Create[Entity]Data, userId: string) {...}
```

## Summary

1. **Data Operations**: All database operations through `db/queries` helper functions
2. **Server Components**: Call query helper functions for data retrieval
3. **Server Actions**: Call mutation helper functions for data modifications
4. **Validation**: Zod schemas defined and exported from query files
5. **Security**: Always include userId parameter and verify ownership
6. **Types**: Export TypeScript types from query files
7. **Organization**: Group related operations by entity in separate query files

This architecture ensures better code organization, reusability, testability, and maintains security while providing clear separation of concerns between data access, business logic, and presentation layers.